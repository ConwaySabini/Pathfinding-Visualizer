{"version":3,"sources":["PathFinder/Node/Node.jsx","Algorithms/Table.js","Algorithms/pqueue.js","Algorithms/Star.js","Algorithms/a-star.js","Algorithms/greedy-bfs.js","Algorithms/dijkstra.js","Algorithms/bfs.js","Algorithms/dfs.js","PathFinder/PathFinder.jsx","App.js","serviceWorker.js","index.js"],"names":["Node","this","props","col","isFinish","isStart","isWall","isWeight","onMouseDown","onMouseEnter","onMouseUp","row","extraClassName","id","className","Component","Table","Row","Col","pqueue","heap","Number","MIN_SAFE_INTEGER","size","length","idx","idx2","tmp","item","index","Math","floor","root","percolateDown","splice","child","undefined","swap","i","Star","gridData","openList","found","g","f","h","source","dest","j","Cell","setValues","MAX_SAFE_INTEGER","isValid","isDestination","getStarPath","finishNode","path","current","unshift","previous","search","grid","data","visited","direction","isVisited","console","log","push","sqrt","euclidean","insert","getGreedPath","dijkstra","start","finish","distance","unvisited","nodes","node","getAllNodes","sortNodes","shift","Infinity","update","sort","a","b","Nodes","filter","next","getUnvisited","updatePath","getNodes","PathFinder","state","isMouseClick","algorithm","finding","isRemove","getGrid","setState","newGrid","getWallGrid","setTimeout","animatePath","document","getElementById","getPath","animate","setvalues","setNodes","first","extractMin","aStar","queue","list","bfs","getBFS","stack","pop","dfs","getDFS","greedyBFS","src","onClick","visualize","clearGrid","clearWalls","clearPath","map","rowIdx","key","nodeIdx","handleMouseDown","handleMouseEnter","handleMouseUp","currentRow","createNode","weight","remove","slice","newNode","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.6d79a381.chunk.js","sourcesContent":["import React, { Component } from 'react';\r\nimport './Node.css';\r\n\r\nexport default class Node extends Component {\r\n    render() {\r\n        const {\r\n            col,\r\n            isFinish,\r\n            isStart,\r\n            isWall,\r\n            isWeight,\r\n            onMouseDown,\r\n            onMouseEnter,\r\n            onMouseUp,\r\n            row,\r\n        } = this.props;\r\n        const extraClassName = isFinish\r\n            ? 'node-finish'\r\n            : isStart\r\n                ? 'node-start'\r\n                : isWall\r\n                    ? 'node-wall'\r\n                    : isWeight\r\n                        ? 'node-weight'\r\n                        : '';\r\n\r\n        return (\r\n            <div\r\n                id={`node-${row}-${col}`}\r\n                className={`node ${extraClassName}`}\r\n                onMouseDown={() => onMouseDown(row, col)}\r\n                onMouseEnter={() => onMouseEnter(row, col)}\r\n                onMouseUp={() => onMouseUp()}>\r\n            </div>\r\n        );\r\n    }\r\n}","export default class Table {\r\n    constructor(Row, Col) {\r\n        this.row = Row; // Row serves as f cost priority queue\r\n        this.col = Col; // Col stores another Table with position\r\n    }\r\n\r\n    setRow(row) {\r\n        this.row = row;\r\n    }\r\n\r\n    setCol(col) {\r\n        this.col = col;\r\n    }\r\n}","import Table from './Table';\r\n\r\nexport default class pqueue {\r\n\r\n    constructor() {\r\n        this.heap = [];\r\n        this.heap[0] = new Table(Number.MIN_SAFE_INTEGER, new Table(0, 0));\r\n        this.size = 0;\r\n    }\r\n\r\n    size() {\r\n        return this.heap.length;\r\n    }\r\n\r\n    swap(idx, idx2) {\r\n        const tmp = this.heap[idx];\r\n        this.heap[idx] = this.heap[idx2];\r\n        this.heap[idx2] = tmp;\r\n    }\r\n\r\n    peek() {\r\n        return this.heap[1];\r\n    }\r\n\r\n    insert(item) {\r\n        if (item === null) return;\r\n        this.heap[0] = item; // 0 index is used as dummy node\r\n        this.size = this.size + 1;\r\n        let index = this.size;\r\n\r\n        while (item.row < this.heap[Math.floor(index / 2)].row) {\r\n            this.heap[index] = this.heap[Math.floor(index / 2)];\r\n            index = Math.floor(index / 2);\r\n        }\r\n        this.heap[index] = item;\r\n    }\r\n\r\n    extractMin() {\r\n        if (this.size === 0) return false;\r\n        const root = this.heap[1];\r\n        this.heap[1] = this.heap[this.size];\r\n        this.size--;\r\n        this.percolateDown(1);\r\n        this.heap.splice(this.size + 1, 1);\r\n        return root;\r\n    }\r\n\r\n    percolateDown(index) {\r\n        let child = Math.floor(index * 2); // smallest child\r\n        if (child > this.size) return;\r\n        if (child !== this.size && this.heap[child + 1] !== undefined &&\r\n            this.heap[child].row > this.heap[child + 1].row) child = child + 1; // confirm smallest\r\n        if (this.heap[child].row < this.heap[index].row) { // if nodes are out of order swap and percolate\r\n            this.swap(child, index);\r\n            this.percolateDown(child);\r\n        }\r\n    }\r\n\r\n    heapify() {\r\n        for (let i = this.size / 2; i > 0; i--) {\r\n            this.percolateDown(i);\r\n        }\r\n    }\r\n}","import pqueue from './pqueue';\r\n\r\nconst ROW = 30;\r\nconst COL = 60;\r\n\r\nexport default class Star {\r\n    constructor() {\r\n        this.gridData = [];\r\n        this.row = -1;\r\n        this.col = -1;\r\n        // set of pair of pair\r\n        this.openList = new pqueue();\r\n        this.found = false;\r\n        this.g = -1;\r\n        this.f = -1;\r\n        this.h = -1;\r\n        this.source = -1;\r\n        this.dest = -1;\r\n    }\r\n\r\n    setvalues() {\r\n        for (let i = 0; i < ROW; i++) {\r\n            this.gridData[i] = []\r\n            for (let j = 0; j < COL; j++) {\r\n                this.gridData[i][j] = new Cell();\r\n                this.gridData[i][j].setValues\r\n                    (Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);\r\n            }\r\n        }\r\n    }\r\n\r\n    setNodes(source, dest) {\r\n        this.source = source;\r\n        this.dest = dest;\r\n    }\r\n}\r\n\r\nclass Cell {\r\n    constructor() {\r\n        this.f = -1; // sum\r\n        this.g = -1; // cost\r\n        this.h = -1; // guess\r\n    }\r\n\r\n    setValues(f, g, h) {\r\n        this.f = f;\r\n        this.g = g;\r\n        this.h = h;\r\n    }\r\n    // f = g + h \r\n}","\r\nimport Table from './Table';\r\nimport Star from './Star';\r\n\r\nconst ROW = 30;\r\nconst COL = 60;\r\n\r\nfunction isValid(row, col) {\r\n    return ((row >= 0) && (row < ROW) &&\r\n        (col >= 0) && (col < COL));\r\n}\r\n\r\nfunction isDestination(row, col, dest) {\r\n    if (row === dest.row && col === dest.col)\r\n        return true;\r\n    else\r\n        return false;\r\n}\r\n\r\nfunction euclidean(row, col, dest) {\r\n    // Euclidean distance formula\r\n    return (Math.sqrt((row - dest.row) * (row - dest.row)\r\n        + (col - dest.col) * (col - dest.col)));\r\n}\r\n\r\n/*function manhattan(row, col, dest) {\r\n    // Manhattan distance formula\r\n    return (Math.abs(row - dest.row) + Math.abs(col - dest.col));\r\n}\r\n\r\nfunction diagonal(row, col, dest) {\r\n    // diagonal distance formula\r\n    return (Math.max(Math.abs(row - dest.row), Math.abs(col - dest.col)));\r\n}*/\r\n\r\nexport function getStarPath(finishNode) {\r\n    const path = [];\r\n    let current = finishNode;\r\n    while (current !== null) {\r\n        path.unshift(current);\r\n        current = current.previous;\r\n    }\r\n    return path;\r\n}\r\n\r\nfunction search(grid, row, col, data, visited, direction) {\r\n    if (isValid(row, col) && !grid[row][col].isVisited) {\r\n        let i = row, j = col;\r\n        switch (direction) {\r\n            case 0:\r\n                i = row + 1;\r\n                break;\r\n            case 1:\r\n                i = row - 1;\r\n                break;\r\n            case 2:\r\n                j = col - 1;\r\n                break;\r\n            case 3:\r\n                j = col + 1;\r\n                break;\r\n            case 4:\r\n                i = row + 1;\r\n                j = col - 1;\r\n                break;\r\n            case 5:\r\n                i = row + 1;\r\n                j = col + 1;\r\n                break;\r\n            case 6:\r\n                i = row - 1;\r\n                j = col - 1;\r\n                break;\r\n            case 7:\r\n                i = row - 1;\r\n                j = col + 1;\r\n                break;\r\n            default:\r\n                console.log(\"direction error\");\r\n                break;\r\n        }\r\n        if (isDestination(row, col, data.dest)) {\r\n            grid[row][col].previous = grid[i][j];\r\n            grid[row][col].isVisited = true;\r\n            visited.push(grid[row][col]);\r\n            data.path = getStarPath(data.dest);\r\n            data.found = true;\r\n            return visited;\r\n        }\r\n        else if (!grid[row][col].isVisited &&\r\n            !grid[row][col].isWall) {\r\n\r\n            if (grid[row][col].isWeight) {\r\n                data.g = data.gridData[i][j].g + 10.0;\r\n            }\r\n            else {\r\n                data.g = data.gridData[i][j].g + 1.0;\r\n            }\r\n            data.h = euclidean(row, col, data.dest);\r\n            data.f = data.g + data.h;\r\n            if (data.gridData[row][col].f === Number.MAX_SAFE_INTEGER ||\r\n                data.gridData[row][col].f > data.f) {\r\n                data.openList.insert(new Table(data.f,\r\n                    new Table(row, col)));\r\n\r\n                data.gridData[row][col].f = data.f;\r\n                data.gridData[row][col].g = data.g;\r\n                data.gridData[row][col].h = data.h;\r\n                grid[row][col].previous = grid[i][j];\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n// A* algorithm\r\nexport function aStar(grid, source, dest) {\r\n    if (!isValid(source.row, source.col) || !isValid(dest.row, dest.col)) {\r\n        console.log(\"Source Node must be on grid\");\r\n        return;\r\n    }\r\n    if (grid[source.row][source.col].isWall || grid[dest.row][dest.col].isWall) {\r\n        console.log(\"There must be a path from the source to the destination\");\r\n        return;\r\n    }\r\n\r\n    if (isDestination(source.row, source.col, dest)) {\r\n        console.log(\"Destination is the source\");\r\n        return;\r\n    }\r\n\r\n    const visited = [];\r\n    const data = new Star();\r\n    data.setvalues();\r\n    data.setNodes(source, dest);\r\n\r\n    data.row = source.row;\r\n    data.col = source.col;\r\n    data.gridData[data.row][data.col].setValues(0.0, 0.0, 0.0);\r\n\r\n    data.openList.insert(new Table(0.0, new Table(data.row, data.col))); // adds start cell with f of 0\r\n\r\n    while (data.openList.size) {\r\n        const first = data.openList.extractMin();\r\n        if (isDestination(first.row, first.col, dest)) {\r\n            return visited;\r\n        }\r\n\r\n        data.row = first.col.row;\r\n        data.col = first.col.col;\r\n        grid[data.row][data.col].isVisited = true;\r\n        visited.push(grid[data.row][data.col]);\r\n\r\n        search(grid, data.row - 1, data.col, data, visited, 0); // North\r\n        if (!data.found) {\r\n            search(grid, data.row + 1, data.col, data, visited, 1); // South\r\n        }\r\n        if (!data.found) {\r\n            search(grid, data.row, data.col + 1, data, visited, 2); // East\r\n        }\r\n        if (!data.found) {\r\n            search(grid, data.row, data.col - 1, data, visited, 3); // West\r\n        }\r\n        if (!data.found) {\r\n            search(grid, data.row - 1, data.col + 1, data, visited, 4); // NE\r\n        }\r\n        if (!data.found) {\r\n            search(grid, data.row - 1, data.col - 1, data, visited, 5); // NW\r\n        }\r\n        if (!data.found) {\r\n            search(grid, data.row + 1, data.col + 1, data, visited, 6); // SE\r\n        }\r\n        if (!data.found) {\r\n            search(grid, data.row + 1, data.col - 1, data, visited, 7); // SW\r\n        }\r\n        if (data.found) {\r\n            return visited;\r\n        }\r\n    }\r\n    // No path found\r\n    if (data.found === false)\r\n        console.log(\"Failed to find path\");\r\n    return visited;\r\n}\r\n","\r\nimport Table from './Table';\r\nimport Star from './Star';\r\n\r\nconst ROW = 30;\r\nconst COL = 60;\r\n\r\nfunction isValid(row, col) {\r\n    return ((row >= 0) && (row < ROW) &&\r\n        (col >= 0) && (col < COL));\r\n}\r\n\r\nfunction isDestination(row, col, dest) {\r\n    if (row === dest.row && col === dest.col)\r\n        return true;\r\n    else\r\n        return false;\r\n}\r\n\r\nfunction euclidean(row, col, dest) {\r\n    // Euclidean distance formula\r\n    return (Math.sqrt((row - dest.row) * (row - dest.row)\r\n        + (col - dest.col) * (col - dest.col)));\r\n}\r\n\r\n/*function manhattan(row, col, dest) {\r\n    // Manhattan distance formula\r\n    return (Math.abs(row - dest.row) + Math.abs(col - dest.col));\r\n}\r\n\r\nfunction diagonal(row, col, dest) {\r\n    // diagonal distance formula\r\n    return (Math.max(Math.abs(row - dest.row), Math.abs(col - dest.col)));\r\n}*/\r\n\r\nexport function getGreedPath(finishNode) {\r\n    const path = [];\r\n    let current = finishNode;\r\n    while (current !== null) {\r\n        path.unshift(current);\r\n        current = current.previous;\r\n    }\r\n    return path;\r\n}\r\n\r\nfunction search(grid, row, col, data, visited, direction) {\r\n    if (isValid(row, col) && !grid[row][col].isVisited) {\r\n        let i = row, j = col;\r\n        switch (direction) {\r\n            case 0:\r\n                i = row + 1;\r\n                break;\r\n            case 1:\r\n                i = row - 1;\r\n                break;\r\n            case 2:\r\n                j = col - 1;\r\n                break;\r\n            case 3:\r\n                j = col + 1;\r\n                break;\r\n            case 4:\r\n                i = row + 1;\r\n                j = col - 1;\r\n                break;\r\n            case 5:\r\n                i = row + 1;\r\n                j = col + 1;\r\n                break;\r\n            case 6:\r\n                i = row - 1;\r\n                j = col - 1;\r\n                break;\r\n            case 7:\r\n                i = row - 1;\r\n                j = col + 1;\r\n                break;\r\n            default:\r\n                console.log(\"direction error\");\r\n                break;\r\n        }\r\n        if (isDestination(row, col, data.dest)) {\r\n            grid[row][col].previous = grid[i][j];\r\n            grid[row][col].isVisited = true;\r\n            visited.push(grid[row][col]);\r\n            data.path = getGreedPath(data.dest);\r\n            data.found = true;\r\n            return visited;\r\n        }\r\n        else if (!grid[row][col].isVisited &&\r\n            !grid[row][col].isWall) {\r\n\r\n            if (grid[row][col].isWeight) {\r\n                data.g = data.gridData[i][j].g + 10.0;\r\n            }\r\n            else {\r\n                data.g = data.gridData[i][j].g + 1.0;\r\n            }\r\n            data.h = euclidean(row, col, data.dest);\r\n            data.f = data.h;\r\n            if (data.gridData[row][col].f === Number.MAX_SAFE_INTEGER ||\r\n                data.gridData[row][col].f > data.f) {\r\n                data.openList.insert(new Table(data.f,\r\n                    new Table(row, col)));\r\n\r\n                data.gridData[row][col].f = data.f;\r\n                data.gridData[row][col].g = data.g;\r\n                data.gridData[row][col].h = data.h;\r\n                grid[row][col].previous = grid[i][j];\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n// Greedy A* algorithm\r\nexport function greedyBFS(grid, source, dest) {\r\n    if (!isValid(source.row, source.col) || !isValid(dest.row, dest.col)) {\r\n        console.log(\"Source Node must be on grid\");\r\n        return;\r\n    }\r\n    if (grid[source.row][source.col].isWall || grid[dest.row][dest.col].isWall) {\r\n        console.log(\"There must be a path from the source to the destination\");\r\n        return;\r\n    }\r\n\r\n    if (isDestination(source.row, source.col, dest)) {\r\n        console.log(\"Destination is the source\");\r\n        return;\r\n    }\r\n\r\n    const visited = [];\r\n    const data = new Star();\r\n    data.setvalues();\r\n    data.setNodes(source, dest);\r\n\r\n    data.row = source.row;\r\n    data.col = source.col;\r\n    data.gridData[data.row][data.col].setValues(0.0, 0.0, 0.0);\r\n\r\n    data.openList.insert(new Table(0.0, new Table(data.row, data.col))); // adds start cell with f of 0\r\n\r\n    while (data.openList.size) {\r\n        const first = data.openList.extractMin();\r\n        if (isDestination(first.row, first.col, dest)) {\r\n            return visited;\r\n        }\r\n\r\n        data.row = first.col.row;\r\n        data.col = first.col.col;\r\n        grid[data.row][data.col].isVisited = true;\r\n        visited.push(grid[data.row][data.col]);\r\n\r\n        search(grid, data.row - 1, data.col, data, visited, 0); // North\r\n        if (!data.found) {\r\n            search(grid, data.row + 1, data.col, data, visited, 1); // South\r\n        }\r\n        if (!data.found) {\r\n            search(grid, data.row, data.col + 1, data, visited, 2); // East\r\n        }\r\n        if (!data.found) {\r\n            search(grid, data.row, data.col - 1, data, visited, 3); // West\r\n        }\r\n        if (!data.found) {\r\n            search(grid, data.row - 1, data.col + 1, data, visited, 4); // NE\r\n        }\r\n        if (!data.found) {\r\n            search(grid, data.row - 1, data.col - 1, data, visited, 5); // NW\r\n        }\r\n        if (!data.found) {\r\n            search(grid, data.row + 1, data.col + 1, data, visited, 6); // SE\r\n        }\r\n        if (!data.found) {\r\n            search(grid, data.row + 1, data.col - 1, data, visited, 7); // SW\r\n        }\r\n        if (data.found) {\r\n            return visited;\r\n        }\r\n    }\r\n    // No path found\r\n    if (data.found === false)\r\n        console.log(\"Failed to find path\");\r\n    return visited;\r\n}\r\n","\r\nexport function dijkstra(grid, start, finish) {\r\n    const visited = [];\r\n    start.distance = 0;\r\n    const unvisited = getAllNodes(grid);\r\n    while (unvisited.length) {\r\n        sortNodes(unvisited);\r\n        const node = unvisited.shift();\r\n        // skip walls\r\n        if (node.isWall) continue;\r\n        if (node.distance === Infinity) return visited;\r\n        node.isVisited = true;\r\n        visited.push(node);\r\n        if (node === finish) return visited;\r\n        update(node, grid);\r\n    }\r\n}\r\n\r\nfunction sortNodes(unvisited) {\r\n    unvisited.sort((a, b) => a.distance - b.distance);\r\n}\r\n\r\n// gets neighbors and updates the previous node in the path and distance\r\nfunction update(node, grid) {\r\n    const unvisited = getUnvisited(node, grid);\r\n    for (const next of unvisited) {\r\n        if (!next.isWeight) {\r\n            next.distance = node.distance + 1;\r\n        }\r\n        else {\r\n            next.distance = node.distance + 10;\r\n        }\r\n        next.previous = node;\r\n    }\r\n}\r\n\r\nfunction getUnvisited(node, grid) {\r\n    const Nodes = [];\r\n    const { col, row } = node;\r\n    if (row > 0) Nodes.push(grid[row - 1][col]);\r\n    if (row < grid.length - 1) Nodes.push(grid[row + 1][col]);\r\n    if (col > 0) Nodes.push(grid[row][col - 1]);\r\n    if (col < grid[0].length - 1) Nodes.push(grid[row][col + 1]);\r\n    return Nodes.filter(next => !next.isVisited);\r\n}\r\n\r\nfunction getAllNodes(grid) {\r\n    const nodes = [];\r\n    for (const row of grid) {\r\n        for (const node of row) {\r\n            nodes.push(node);\r\n        }\r\n    }\r\n    return nodes;\r\n}\r\n\r\nexport function getPath(finishNode) {\r\n    const path = [];\r\n    let current = finishNode;\r\n    while (current !== null) {\r\n        path.unshift(current);\r\n        current = current.previous;\r\n    }\r\n    return path;\r\n}","export function bfs(grid, start, finish) {\r\n    const queue = [];\r\n    queue.push(start);\r\n    const visited = [];\r\n    start.isVisited = true;\r\n\r\n    while (queue.length) {\r\n        const current = queue.shift();\r\n        if (current.isWall) continue;\r\n        visited.push(current);\r\n        if (current.row === finish.row && current.col === finish.col) {\r\n            return visited;\r\n        }\r\n        const list = updatePath(current, grid);\r\n        for (const node of list) {\r\n            queue.push(node);\r\n            node.isVisited = true;\r\n        }\r\n    }\r\n    console.log(\"failed to find path\");\r\n    return visited;\r\n}\r\n\r\nfunction getNodes(node, grid) {\r\n    const { row, col } = node;\r\n    let next = [];\r\n    if (row > 0) {\r\n        if (!grid[row - 1][col].isVisited) next.push(grid[row - 1][col]);\r\n    }\r\n    if (row < grid.length - 1) {\r\n        if (!grid[row + 1][col].isVisited) next.push(grid[row + 1][col]);\r\n    }\r\n    if (col > 0) {\r\n        if (!grid[row][col - 1].isVisited) next.push(grid[row][col - 1]);\r\n    }\r\n    if (col < grid[0].length - 1) {\r\n        if (!grid[row][col + 1].isVisited) next.push(grid[row][col + 1]);\r\n    }\r\n    return next;\r\n}\r\n\r\nfunction updatePath(current, grid) {\r\n    const unvisited = getNodes(current, grid);\r\n    for (const next of unvisited) {\r\n        next.previous = current;\r\n    }\r\n    return unvisited;\r\n}\r\n\r\nexport function getBFS(finishNode) {\r\n    const path = [];\r\n    let current = finishNode;\r\n    while (current !== null) {\r\n        path.unshift(current);\r\n        current = current.previous;\r\n    }\r\n    return path;\r\n}","\r\n// returns the visited nodes in the dfs\r\nexport function dfs(grid, start, finish) {\r\n    const stack = [];\r\n    stack.push(start);\r\n    const visited = [];\r\n\r\n    while (stack.length) {\r\n        const current = stack.pop();\r\n        if (current.isWall) continue;\r\n        visited.push(current);\r\n        if (current.row === finish.row && current.col === finish.col) {\r\n            return visited;\r\n        }\r\n        let unvisited = [];\r\n\r\n        if (!current.isVisited) {\r\n            current.isVisited = true;\r\n        }\r\n        unvisited = updatePath(current, grid, visited);\r\n        for (const node of unvisited) {\r\n            stack.push(node);\r\n            node.isVisited = true;\r\n            if (node.row === finish.row && node.col === finish.col) {\r\n                return visited;\r\n            }\r\n        }\r\n    }\r\n    console.log(\"failed to find path\");\r\n    return visited;\r\n}\r\n\r\n// returns the list of unvisited next nodes to add to the stack\r\nfunction getNodes(node, grid, direction, visited) {\r\n    let { row, col } = node;\r\n    let next = [];\r\n    switch (direction) {\r\n        case \"up\":\r\n            while (row > 0 && !grid[row - 1][col].isWall) {\r\n                next.push(grid[row - 1][col]);\r\n                if (row !== 1) visited.push(grid[row - 1][col]);\r\n                if (grid[row - 1][col].previous === null) grid[row - 1][col].previous = grid[row][col];\r\n                row--;\r\n            }\r\n            break;\r\n        case \"right\":\r\n            while (col < grid[0].length - 1 && !grid[row][col + 1].isWall) {\r\n                next.push(grid[row][col + 1]);\r\n                if (col !== grid[0].length - 1) visited.push(grid[row][col + 1]);\r\n                if (grid[row][col + 1].previous === null) grid[row][col + 1].previous = grid[row][col];\r\n                col++;\r\n            }\r\n            break;\r\n        case \"down\":\r\n            while (row < grid.length - 1 && !grid[row + 1][col].isWall) {\r\n                next.push(grid[row + 1][col]);\r\n                if (row !== grid.length - 1) visited.push(grid[row + 1][col]);\r\n                if (grid[row + 1][col].previous === null) grid[row + 1][col].previous = grid[row][col];\r\n                row++;\r\n            }\r\n            break;\r\n        case \"left\":\r\n            if (col > 0 && !grid[row][col - 1].isWall) {\r\n                next.push(grid[row][col - 1]);\r\n                visited.push(grid[row][col]);\r\n                if (grid[row][col - 1].previous === null) grid[row][col - 1].previous = grid[row][col];\r\n            }\r\n            break;\r\n        default:\r\n            break;\r\n    }\r\n    return next;\r\n}\r\n\r\n// determines the direction to move and returns the unvisited nodes in that depth\r\nfunction updatePath(node, grid, visited) {\r\n    const { row, col } = node;\r\n    let direction = \"\";\r\n    if (node.row > 0 && !grid[row - 1][col].isVisited && !grid[row - 1][col].isWall) direction = \"up\";\r\n    else if (node.col < grid[0].length - 1 && !grid[row][col + 1].isVisited && !grid[row][col + 1].isWall) direction = \"right\";\r\n    else if (node.row < grid.length - 1 && !grid[row + 1][col].isVisited && !grid[row + 1][col].isWall) direction = \"down\";\r\n    else if (node.col > 0 && !grid[row][col - 1].isVisited && !grid[row][col - 1].isWall) direction = \"left\";\r\n    const unvisited = getNodes(node, grid, direction, visited);\r\n    return unvisited;\r\n}\r\n\r\n// returns the dfs path\r\nexport function getDFS(finishNode) {\r\n    const path = [];\r\n    let current = finishNode;\r\n    while (current !== null) {\r\n        path.unshift(current);\r\n        current = current.previous;\r\n    }\r\n    console.log(current);\r\n    return path;\r\n}","\r\n\r\n//TODO MAKE UI LOOK LIKE MINE\r\n//TODO, Add Mazes with generation\r\n//TODO, Error handling\r\n//TODO, Add Bidirectional Searching support\r\nimport React, { Component } from 'react';\r\nimport Node from './Node/Node';\r\nimport { aStar, getStarPath } from '../Algorithms/a-star';\r\nimport { greedyBFS, getGreedPath } from '../Algorithms/greedy-bfs';\r\nimport { dijkstra, getPath } from '../Algorithms/dijkstra';\r\nimport { bfs, getBFS } from '../Algorithms/bfs';\r\nimport { dfs, getDFS } from '../Algorithms/dfs';\r\n\r\nimport './PathFinder.css';\r\n\r\nconst START_ROW = 5;\r\nconst START_COL = 10;\r\nconst FINISH_ROW = 10;\r\nconst FINSIH_COL = 50;\r\n\r\nexport default class PathFinder extends Component {\r\n    constructor() {\r\n        super();\r\n        this.state = {\r\n            grid: [],\r\n            isMouseClick: false,\r\n            algorithm: \"dijkstra\",\r\n            finding: false,\r\n            isWeight: false,\r\n            isRemove: false,\r\n        };\r\n    }\r\n\r\n    componentDidMount() {\r\n        const grid = getGrid();\r\n        this.setState({ grid });\r\n    }\r\n\r\n    handleMouseDown(row, col) {\r\n        const { finding, isWeight, isRemove } = this.state;\r\n        console.log(isWeight);\r\n        if (!finding) {\r\n            const newGrid = getWallGrid(this.state.grid, row, col, isWeight, isRemove);\r\n            this.setState({ grid: newGrid, isMouseClick: true });\r\n        }\r\n    }\r\n\r\n    handleMouseEnter(row, col) {\r\n        const { finding, isWeight, isRemove } = this.state;\r\n        if (!finding) {\r\n            if (!this.state.isMouseClick) return;\r\n            const newGrid = getWallGrid(this.state.grid, row, col, isWeight, isRemove);\r\n            this.setState({ grid: newGrid });\r\n        }\r\n    }\r\n\r\n    handleMouseUp() {\r\n        this.setState({ isMouseClick: false });\r\n    }\r\n\r\n    animate(visited, path) {\r\n        for (let i = 0; i <= visited.length; i++) {\r\n            if (i === visited.length) {\r\n                setTimeout(() => {\r\n                    this.animatePath(path);\r\n                }, 10 * i);\r\n                return;\r\n            }\r\n            setTimeout(() => {\r\n                const node = visited[i];\r\n                document.getElementById(`node-${node.row}-${node.col}`).className =\r\n                    'node node-visited';\r\n            }, 10 * i);\r\n        }\r\n    }\r\n\r\n    animatePath(path) {\r\n        for (let i = 0; i < path.length; i++) {\r\n            setTimeout(() => {\r\n                const node = path[i];\r\n                document.getElementById(`node-${node.row}-${node.col}`).className =\r\n                    'node node-shortest-path';\r\n            }, 50 * i);\r\n        }\r\n    }\r\n\r\n    visualize() {\r\n        const { grid } = this.state;\r\n        const source = grid[START_ROW][START_COL];\r\n        const dest = grid[FINISH_ROW][FINSIH_COL];\r\n        const { algorithm } = this.state;\r\n        let finding = true;\r\n        this.setState({ finding });\r\n        let visited, path;\r\n        switch (algorithm) {\r\n            case \"dijkstra\":\r\n                visited = dijkstra(grid, source, dest);\r\n                path = getPath(dest);\r\n                this.animate(visited, path);\r\n                break;\r\n            case \"A*\":\r\n                visited = aStar(grid, source, dest);\r\n                path = getStarPath(dest);\r\n                this.animate(visited, path);\r\n                break;\r\n            case \"BFS\":\r\n                visited = bfs(grid, source, dest);\r\n                path = getBFS(dest);\r\n                this.animate(visited, path);\r\n                break;\r\n            case \"DFS\":\r\n                visited = dfs(grid, source, dest);\r\n                path = getDFS(dest);\r\n                this.animate(visited, path);\r\n                break;\r\n            case \"BestFS\":\r\n                visited = greedyBFS(grid, source, dest);\r\n                path = getGreedPath(dest);\r\n                this.animate(visited, path);\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n        finding = false;\r\n        this.setState({ finding });\r\n    }\r\n\r\n    clearWalls() {\r\n        const { finding, grid } = this.state;\r\n        if (!finding) {\r\n            for (let i = 0; i < grid.length; i++) {\r\n                const row = grid[i]\r\n                for (let j = 0; j < row.length; j++) {\r\n                    const node = row[j];\r\n                    if (node.isFinish) {\r\n                        document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-finish';\r\n                    }\r\n                    else if (node.isStart) {\r\n                        document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-start';\r\n                    }\r\n                    else if (node.isWall) {\r\n                        document.getElementById(`node-${node.row}-${node.col}`).className = 'node';\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    clearGrid() {\r\n        const { finding } = this.state;\r\n        if (!finding) {\r\n            const grid = getGrid();\r\n            this.setState({ grid });\r\n            for (let i = 0; i < grid.length; i++) {\r\n                const row = grid[i]\r\n                for (let j = 0; j < row.length; j++) {\r\n                    const node = row[j];\r\n                    if (node.isFinish) {\r\n                        document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-finish';\r\n                    }\r\n                    else if (node.isStart) {\r\n                        document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-start';\r\n                    }\r\n                    else {\r\n                        document.getElementById(`node-${node.row}-${node.col}`).className = 'node';\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    clearPath() { // FIX bug where path nodes are\r\n        const { finding, grid } = this.state;\r\n        if (!finding) {\r\n            for (let i = 0; i < grid.length; i++) {\r\n                const row = grid[i]\r\n                for (let j = 0; j < row.length; j++) {\r\n                    const node = row[j];\r\n                    if (node.isFinish) {\r\n                        document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-finish';\r\n                    }\r\n                    else if (node.isStart) {\r\n                        document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-start';\r\n                    }\r\n                    else if (node.isVisited) {\r\n                        document.getElementById(`node-${node.row}-${node.col}`).className = 'node';\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    render() {\r\n        const { grid, isMouseClick } = this.state;\r\n\r\n        return (\r\n            <>\r\n                <script src=\"priority-queue.js\"></script>\r\n                <div className=\"nav\">\r\n                    <div className=\"dropdown\">\r\n                        <button className=\"dropbtn\">Algorithms</button>\r\n                        <div className=\"dropdown-content\">\r\n                            <button className=\"algorithm\" onClick={() => {\r\n                                const { finding } = this.state;\r\n                                if (!finding) {\r\n                                    const algorithm = \"dijkstra\";\r\n                                    this.setState({ algorithm });\r\n                                }\r\n                            }}>Dijkstra's</button>\r\n                            <button className=\"algorithm\" onClick={() => {\r\n                                const { finding } = this.state;\r\n                                if (!finding) {\r\n                                    const algorithm = \"A*\";\r\n                                    this.setState({ algorithm });\r\n                                }\r\n                            }}>A*</button>\r\n                            <button className=\"algorithm\" onClick={() => {\r\n                                const { finding } = this.state;\r\n                                if (!finding) {\r\n                                    const algorithm = \"BFS\";\r\n                                    this.setState({ algorithm });\r\n                                }\r\n                            }}>Breadth-First-Search</button>\r\n                            <button className=\"algorithm\" onClick={() => {\r\n                                const { finding } = this.state;\r\n                                if (!finding) {\r\n                                    const algorithm = \"DFS\";\r\n                                    this.setState({ algorithm });\r\n                                }\r\n                            }}>Depth-First-Search</button>\r\n                            <button className=\"algorithm\" onClick={() => {\r\n                                const { finding } = this.state;\r\n                                if (!finding) {\r\n                                    const algorithm = \"BestFS\";\r\n                                    this.setState({ algorithm });\r\n                                }\r\n                            }}>Best-First-Search</button>\r\n                        </div>\r\n                    </div>\r\n                    <div className=\"dropdown\">\r\n                        <button className=\"dropbtn\">Edit Nodes</button>\r\n                        <div className=\"dropdown-content\">\r\n                            <button className=\"weight\" onClick={() => {\r\n                                this.setState({ isRemove: false });\r\n                                const { finding } = this.state;\r\n                                if (!finding) {\r\n                                    const isWeight = false;\r\n                                    this.setState({ isWeight });\r\n                                }\r\n                            }}>Place Wall</button>\r\n                            <button className=\"weight\" onClick={() => {\r\n                                const { finding } = this.state;\r\n                                this.setState({ isRemove: false });\r\n                                if (!finding) {\r\n                                    const isWeight = true;\r\n                                    this.setState({ isWeight });\r\n                                }\r\n                            }}>Place Weight Node</button>\r\n                            <button className=\"weight\" onClick={() => {\r\n                                const { finding } = this.state;\r\n                                if (!finding) {\r\n                                    const isRemove = true;\r\n                                    this.setState({ isRemove });\r\n                                }\r\n                            }}>Remove Node</button>\r\n                        </div>\r\n                    </div>\r\n                    <button onClick={() => {\r\n                        const { finding } = this.state;\r\n                        if (!finding) {\r\n                            this.visualize();\r\n                        }\r\n                    }}>Visualize</button>\r\n                    <button onClick={() => {\r\n                        const { finding } = this.state;\r\n                        if (!finding) {\r\n                            this.clearGrid();\r\n                        }\r\n                    }}>Clear Board</button>\r\n                    <button onClick={() => {\r\n                        const { finding } = this.state;\r\n                        if (!finding) {\r\n                            this.clearWalls();\r\n                        }\r\n                    }}>Clear Walls</button>\r\n                    <button onClick={() => {\r\n                        const { finding } = this.state;\r\n                        if (!finding) {\r\n                            this.clearPath();\r\n                        }\r\n                    }}>Clear Path</button>\r\n                </div>\r\n                <div className=\"grid\">\r\n                    {grid.map((row, rowIdx) => {\r\n                        return (\r\n                            <div key={rowIdx}>\r\n                                {row.map((node, nodeIdx) => {\r\n                                    const { row, col, isFinish, isStart, isWall, isWeight } = node;\r\n                                    return (\r\n                                        <Node\r\n                                            key={nodeIdx}\r\n                                            col={col}\r\n                                            isFinish={isFinish}\r\n                                            isStart={isStart}\r\n                                            isWall={isWall}\r\n                                            isWeight={isWeight}\r\n                                            isMouseClick={isMouseClick}\r\n                                            onMouseDown={(row, col) => this.handleMouseDown(row, col)}\r\n                                            onMouseEnter={(row, col) =>\r\n                                                this.handleMouseEnter(row, col)\r\n                                            }\r\n                                            onMouseUp={() => this.handleMouseUp()}\r\n                                            row={row}>\r\n                                        </Node>\r\n                                    );\r\n                                })}\r\n                            </div>\r\n                        );\r\n                    })}\r\n                </div>\r\n            </>\r\n        );\r\n    }\r\n}\r\n\r\nconst getGrid = () => {\r\n    const grid = [];\r\n    for (let row = 0; row < 30; row++) {\r\n        const currentRow = [];\r\n        for (let col = 0; col < 60; col++) {\r\n            currentRow.push(createNode(col, row));\r\n        }\r\n        grid.push(currentRow);\r\n    }\r\n    return grid;\r\n};\r\n\r\nconst createNode = (col, row) => {\r\n    return {\r\n        col,\r\n        row,\r\n        isStart: row === START_ROW && col === START_COL,\r\n        isFinish: row === FINISH_ROW && col === FINSIH_COL,\r\n        distance: Infinity,\r\n        isVisited: false,\r\n        isWeight: false,\r\n        isWall: false,\r\n        previous: null,\r\n    };\r\n};\r\n\r\nconst getWallGrid = (grid, row, col, weight, remove) => {\r\n    const newGrid = grid.slice();\r\n    const node = newGrid[row][col];\r\n    const newNode = {\r\n        ...node,\r\n    };\r\n    if (weight && !remove) {\r\n        newNode.isWeight = true;\r\n        newNode.isWall = false;\r\n    }\r\n    else if (!remove && !node.isWall) {\r\n        newNode.isWall = true;\r\n    }\r\n    else {\r\n        newNode.isWall = false;\r\n        newNode.isWeight = false;\r\n    }\r\n    newGrid[row][col] = newNode;\r\n    return newGrid;\r\n};\r\n","import React from 'react';\nimport PathFinder from './PathFinder/PathFinder';\nimport './App.css';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathFinder></PathFinder>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}